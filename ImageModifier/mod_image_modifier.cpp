/*
this file cant be a .cpp file.
it will copmpile, but apache wont be abnle to load it

if you wrap c stuff around c++  like i did here, then you can load it?

C:\wamp\bin\apache\ApacheX.X.XX\modules
then left click wamp icon > apache > httpd.conf
find the module section
add this line to the end of the section
LoadModule MODULENAME modules/MODULENAME.so
So you'll use
LoadModule imap_module modules/mod_imap.so

*  mod_helloworld.c -- Apache sample helloworld module
*  [Autogenerated via ``apxs -n helloworld -g'']
*
*  To play with this sample module first compile it into a
*  DSO file and install it into Apache's modules directory
*  by running:
*
*    $ apxs -c -i mod_helloworld.c
*
*  Then activate it in Apache's httpd.conf file for instance
*  for the URL /helloworld in as follows:
*
*    # httpd.conf
*    LoadModule helloworld_module modules/mod_helloworld.so


*    <Location /hello>   //<- this tells apache what the url is for the modul
*      SetHandler helloworld  //<- this is the module to run when we hit that url
*    </Location>
*
*  Then after restarting Apache via
*
*    $ apachectl restart
*
*  you immediately can request the URL /helloworld and watch for the
*  output of this module. This can be achieved for instance via:
*
*    $ lynx -mime_header http://localhost/hello
*/

#include "mod_image_modifier.h"

#include <stdio.h>
#include <string>
#include <vector>

#include "stb_image.h"
#include "stb_image_write.h"

#include "BitmapFont.h"
#include "StringUtils.h"
#include <time.h>

using namespace std;


//---------------------------------------------------------------------------------------------------
unsigned int GetRandomNum(int min, int max)
{
	unsigned int diff = ((max - min) + 1);
	return ((diff * rand()) / RAND_MAX) + min;
}
//---------------------------------------------------------------------------------------------------
float GetRandomFloat(float min, float max)
{
	return min + static_cast <float> (rand()) / (static_cast <float> (RAND_MAX / (max - min)));
}
//---------------------------------------------------------------------------------------------------
RGBA GetPixelsAvgColor(PIXMAP *bmp, int x, int y, int w, int h)
{

	RGBA *runner;
	int r = 0, g = 0, b = 0, a = 0; //use ints so we dont have to worry about overflow when adding
	int counter = 0;
	for (unsigned int uiV = y; uiV < (y + h); ++uiV)
	{
		// reset coordinate for each row
		runner = &bmp->pixels[uiV * bmp->w + x];

		// read each row
		for (unsigned int uiH = x; uiH < (x + w); ++uiH)
		{
			r += runner->r;
			g += runner->g;
			b += runner->b;
			a += runner->a;
			runner++;
			counter++;
		}
	}
	r += (counter / 2);
	g += (counter / 2);
	b += (counter / 2);
	a += (counter / 2);

	r /= counter;
	g /= counter;
	b /= counter;
	a /= counter;

	return RGBA{ (unsigned char)r,(unsigned char)g,(unsigned char)b,(unsigned char)a };
}

string GetArgValue(std::vector<std::string>args, std::string key)
{
	for (size_t i = 0; i < args.size(); i++)
	{
		vector<string> pair = StringUtils::Tokenize(args[i], "=");

		if (pair.size() < 2)
			continue;
		else if (pair[0] == key)
			return pair[1];
	}

	return "";
}


static void Run(request_rec *req)
{
	string inputFile, outputDir;
	string outputFileNameOnly;
	string destFile;
	//string fileExt;
	string waterMarkText;
	PIXMAP *img2 = new PIXMAP(10, 10);
	PIXMAP *photo;
	bool addBorder = true;
	bool addTint = true;
	unsigned char *finalImageRawPixels;
	char slash = '\\';
	string ret;
	srand(time(0));
	bool error = false;
	int bw;
	int bh;
	int bpp;
	
	string args = req->args;
	vector<string> argTokens = StringUtils::Tokenize(args, "&");
	inputFile = GetArgValue(argTokens, "input");
	outputDir = GetArgValue(argTokens, "output");
	waterMarkText = GetArgValue(argTokens, "text");

	//ap_log_error(__FILE__, __LINE__, 0, APLOG_INFO, 0, req->server, "-------------MY TEST!!!! Entered Function = hello_handler, time = %d", req->finfo.mtime);
	if (inputFile.empty())
	{
		//ap_log_error(__FILE__, __LINE__, 0, APLOG_INFO, 0, req->server, "Entered Function = hello_handler, time = %d", req->finfo.mtime);
		ret += "specify a .png or .jpg image to modify. Use the param -i or --input\n";
		ret += "\nyou can optionally specify the fully qualified output path or path+filename using -o or --output\n";
		error = true;
	}
	unsigned char* imgData = stbi_load(inputFile.c_str(), &bw, &bh, &bpp, 4);
	if (!imgData)
	{
		ret += "\ncouldnt load image: " + inputFile;
		error = true;
	}

	//std::size_t found = inputFile.find_last_of(".");
	//fileExt = inputFile.substr(found + 1);


	if (outputDir.empty())
	{
		outputDir = inputFile.substr(0, inputFile.find_last_of("/\\") + 1);
	}

	if (outputDir.back() != slash && outputDir.find_last_of(".") == string::npos)
	{
		outputDir += slash;
	}



	if (outputDir.find_last_of(".") == string::npos)
		outputFileNameOnly = inputFile.substr(inputFile.find_last_of("/\\") + 1);
	else
	{
		outputFileNameOnly = outputDir.substr(outputDir.find_last_of("/\\") + 1);
		outputDir = outputDir.substr(0, outputDir.find_last_of("/\\") + 1);
	}
	outputFileNameOnly = outputFileNameOnly.substr(0, outputFileNameOnly.find_last_of("."));//remove file ext

																							//if the dest file is in a differnt dir than src file, dont add a modfied marker
	string inputDir = inputFile.substr(0, inputFile.find_last_of("/\\") + 1);

	if (outputDir == inputDir)
		destFile = outputDir + "modified_" + outputFileNameOnly + ".png";
	else
		destFile = outputDir + outputFileNameOnly + ".png";

	string inputFileExt = inputFile.substr(inputFile.find_last_of(".") + 1);//remove file ext 

	

	photo = new PIXMAP(imgData, bw, bh);
	//once the data ahs been copied into our class, get rid of raw data
	stbi_image_free(imgData);

	if (!photo)//sometimes the bmp fails to load, until i figure out why, ill just do this
	{
		photo = nullptr;
		ret += "\ncouldnt convert image into PIXMAP: " + inputFile;
	}


	bw *= GetRandomFloat(0.5f, 1.5f);
	bh *= GetRandomFloat(0.5f, 1.5f);

	photo->Scale(bw, bh);

	//do we want to add a color tint?
	if (GetRandomNum(0, 100) > 50)
		addTint = false;
	if (addTint)
	{
		int amt = GetRandomNum(10, 50);
		int gun = GetRandomNum(0, 90);

		for (int i = 0; i < (bw * bh); i++)
		{
			if (gun >= 0 && gun <= 30)
			{
				if (photo->pixels[i].r < (255 - amt))
					photo->pixels[i].r += amt;
				else
					photo->pixels[i].r = 255;
			}
			else if (gun >= 31 && gun <= 60)
			{
				if (photo->pixels[i].g < (255 - amt))
					photo->pixels[i].g += amt;
				else
					photo->pixels[i].g = 255;
			}
			else
			{
				if (photo->pixels[i].b < (255 - amt))
					photo->pixels[i].b += amt;
				else
					photo->pixels[i].b = 255;
			}
		}
	}
	//add the water mark if there is one
	if (!waterMarkText.empty())
	{
		for (int i = 0; i < 10; i++)
		{
			StockBitmapFont testFont;
			int xPos = GetRandomNum(0, bw - 1);
			int yPos = GetRandomNum(0, bh - 1);
			testFont.Draw(photo, waterMarkText, xPos, yPos, true);
		}
	}

	//add random "transparent marks" to change up some pixels even more
	for (int i = 0; i < 50; i++)
	{
		int pix = GetRandomNum(0, (bw * bh));
		photo->pixels[pix] = RGBA{ (unsigned char)GetRandomNum(0,255),(unsigned char)GetRandomNum(0,255),(unsigned char)GetRandomNum(0,255),255 };

		int xx = GetRandomNum(0, (bw - 10));
		int yy = GetRandomNum(0, (bh - 10));

		RGBA col = GetPixelsAvgColor(photo, xx, yy, 8, 8);
		StockBitmapFont testFont(col);
		testFont.Draw(photo, "X", xx, yy, true);
	}

	//do we want to add a border?
	if (GetRandomNum(0, 100) > 50)
		addBorder = false;

	if (addBorder)
	{
		int borderSize = GetRandomNum(10, 20);
		PIXMAP *border = new PIXMAP(photo->w + borderSize, photo->h + borderSize);

		//do we want to add a border?
		if (GetRandomNum(0, 100) > 50)
			border->Fill(RGBA{ (unsigned char)GetRandomNum(0,255),(unsigned char)GetRandomNum(0,255),(unsigned char)GetRandomNum(0,255),255 });
		else
		{
			for (int i = 0; i < border->w; i++)
				for (int j = 0; j < border->h; j++)
					border->PutPixel(RGBA{ (unsigned char)GetRandomNum(0,255),(unsigned char)GetRandomNum(0,255),(unsigned char)GetRandomNum(0,255),255 }, i, j);
		}

		photo->Blit(border, borderSize / 2, borderSize / 2);
		finalImageRawPixels = (unsigned char *)border->pixels;
		bw = border->w;
		bh = border->h;
	}
	else
		finalImageRawPixels = (unsigned char *)photo->pixels;

	//4th param = comp, which is 1=Y, 2=YA, 3=RGB, 4=RGBA.
	stbi_write_png(destFile.c_str(), bw, bh, 4, finalImageRawPixels, bw * sizeof(unsigned int));
	ret += "\nsuccess! new file: " + destFile;


	ap_rputs(ret.c_str(), req);
	req->content_type = "application/json;charset=UTF-8";
	
}
EXTERN_C_FUNC
static int image_modifier_handler(request_rec *req)
{
	//the handler name
	if (strcmp(req->handler, "image_modifier")) 
	{
		return DECLINED;
	}


	if(req->method_number == M_GET)
	{
		if(strcmp(req->path_info, "/random")==0)
			Run(req);
	}
	else
	{
		ap_rputs("i dunno", req);
		req->content_type = "text/plain;charset=UTF-8";
	}
	// ap_table_set is too old API
	apr_table_set(req->headers_out, "X-Content-Type-Options", "nosniff");

	return OK;
}

EXTERN_C_FUNC
static void image_modifier_register_hooks(apr_pool_t *p)
{
	printf("\n ** image_modifier_register_hooks  **\n\n");
	ap_hook_handler(image_modifier_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

EXTERN_C_BLOCK_BEGIN
/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA image_modifier_module = { //is this the name of the module?
	STANDARD20_MODULE_STUFF,
	NULL, /* create per-dir    config structures */
	NULL, /* merge  per-dir    config structures */
	NULL, /* create per-server config structures */
	NULL, /* merge  per-server config structures */
	NULL, /* table of config file commands       */
	image_modifier_register_hooks  /* register hooks */
};
EXTERN_C_BLOCK_END